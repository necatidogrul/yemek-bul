/**
 * RevenueCat Service
 *
 * Premium subscription ve in-app purchase y√∂netimi
 */

import Purchases, {
  CustomerInfo,
  PurchasesOffering,
  PurchasesPackage,
  LOG_LEVEL,
} from 'react-native-purchases';
import { Platform } from 'react-native';
import Constants from 'expo-constants';
import { Logger } from './LoggerService';
import {
  REVENUECAT_CONFIG,
  PREMIUM_FEATURES,
  PremiumFeature,
} from '../config/revenueCat';

// Environment helpers
const isProduction = () => !__DEV__;
const debugLog = (message: string, data?: any) => {
  if (__DEV__) {
    Logger.info(message, data || '');
  }
};

export interface PremiumStatus {
  isPremium: boolean;
  isActive: boolean;
  expirationDate?: Date;
  originalPurchaseDate?: Date;
  productId?: string;
  willRenew?: boolean;
}

export interface PurchaseResult {
  success: boolean;
  customerInfo?: CustomerInfo;
  error?: string;
  userCancelled?: boolean;
}

export class RevenueCatService {
  private static isInitialized = false;
  private static currentCustomerInfo: CustomerInfo | null = null;
  private static initializationPromise: Promise<void> | null = null;

  /**
   * RevenueCat SDK'sƒ±nƒ± ba≈ülat (singleton pattern)
   */
  static async initialize(): Promise<void> {
    // Eƒüer zaten initialize ediliyorsa bekle
    if (this.initializationPromise) {
      return this.initializationPromise;
    }

    // Eƒüer zaten initialize edildiyse return
    if (this.isInitialized) {
      debugLog('‚úÖ RevenueCat already initialized');
      return;
    }

    // Initialize i≈ülemini ba≈ülat
    this.initializationPromise = this.performInitialization();

    try {
      await this.initializationPromise;
    } finally {
      this.initializationPromise = null;
    }
  }

  private static async performInitialization(): Promise<void> {
    try {
      // Expo Go kontrol√º
      const isExpoGo = Constants.appOwnership === 'expo';

      if (isExpoGo) {
        Logger.warn('üì± Expo Go detected - RevenueCat will use mock mode');
        this.isInitialized = true;
        this.currentCustomerInfo = null;
        return;
      }

      debugLog('üîß Checking RevenueCat SDK status...');

      // SDK'nƒ±n configure edilip edilmediƒüini kontrol et - retry logic ile
      let retryCount = 0;
      const maxRetries = 5;
      const retryDelay = 1000;

      while (retryCount < maxRetries) {
        try {
          // Customer info'yu almayƒ± dene
          const customerInfo = await Purchases.getCustomerInfo();
          debugLog('‚úÖ RevenueCat SDK configured and ready');
          this.currentCustomerInfo = customerInfo;
          this.isInitialized = true;
          return;
        } catch (error: any) {
          // SDK hen√ºz configure edilmemi≈ü veya hazƒ±r deƒüil
          if (
            error.message?.includes('configure') ||
            error.message?.includes('singleton') ||
            error.message?.includes('not configured')
          ) {
            retryCount++;

            if (retryCount < maxRetries) {
              debugLog(
                `‚è≥ Waiting for SDK configuration... (attempt ${retryCount}/${maxRetries})`
              );
              await new Promise(resolve => setTimeout(resolve, retryDelay));
              continue;
            }

            // Son deneme ba≈üarƒ±sƒ±z
            Logger.error(
              '‚ùå RevenueCat SDK could not be accessed after retries'
            );

            // Development'ta mock mode'a ge√ß
            if (__DEV__) {
              debugLog('üîß Development mode - using mock mode');
              this.isInitialized = true;
              this.currentCustomerInfo = null;
              return;
            }

            throw new Error(
              'RevenueCat SDK not ready. Please ensure Purchases.configure() is called in App.tsx'
            );
          }

          // Ba≈üka bir hata
          throw error;
        }
      }
    } catch (error) {
      Logger.error('‚ùå RevenueCat initialization failed:', error);

      // Development'ta mock mode'a ge√ß
      if (__DEV__) {
        debugLog('üîß Development mode - using mock mode');
        this.isInitialized = true;
        this.currentCustomerInfo = null;
        return;
      }

      throw error;
    }
  }

  /**
   * Kullanƒ±cƒ± bilgilerini g√ºncelle
   */
  static async refreshCustomerInfo(forceRefresh = false): Promise<CustomerInfo | null> {
    try {
      if (!this.isInitialized) {
        await this.initialize();
      }

      // Expo Go mock
      if (Constants.appOwnership === 'expo') {
        debugLog('üì± Expo Go: Using mock customer info');
        return null;
      }

      debugLog(`üîÑ Refreshing customer info (force: ${forceRefresh})`);
      
      // Force refresh i√ßin cache'i bypass et
      let customerInfo: CustomerInfo;
      if (forceRefresh) {
        // Cache'i bypass etmek i√ßin restore'dan sonra get yapalƒ±m
        try {
          // Sandbox'ta restore purchases √ßaƒüƒ±rarak cache'i temizleyelim
          debugLog('üîÑ Force refresh: Restoring purchases to clear cache');
          customerInfo = await Purchases.restorePurchases();
        } catch (restoreError) {
          debugLog('‚ö†Ô∏è Restore failed, falling back to getCustomerInfo');
          customerInfo = await Purchases.getCustomerInfo();
        }
      } else {
        customerInfo = await Purchases.getCustomerInfo();
      }
      
      this.currentCustomerInfo = customerInfo;

      debugLog('üìä Customer info refreshed:', {
        userId: customerInfo.originalAppUserId,
        activeSubscriptions: Object.keys(customerInfo.activeSubscriptions),
        activeEntitlements: Object.keys(customerInfo.entitlements.active),
        entitlementsDetail: Object.fromEntries(
          Object.entries(customerInfo.entitlements.active).map(([key, entitlement]) => [
            key, 
            {
              isActive: entitlement.isActive,
              willRenew: entitlement.willRenew,
              productId: entitlement.productIdentifier,
              expirationDate: entitlement.expirationDate
            }
          ])
        )
      });

      return customerInfo;
    } catch (error) {
      Logger.error('‚ùå Failed to refresh customer info:', error);

      if (__DEV__) {
        return null;
      }

      throw error;
    }
  }

  /**
   * Mevcut premium durumunu kontrol et
   */
  static async getPremiumStatus(forceRefresh = false): Promise<PremiumStatus> {
    try {
      if (!this.currentCustomerInfo || forceRefresh) {
        await this.refreshCustomerInfo(forceRefresh);
      }

      if (!this.currentCustomerInfo) {
        debugLog('‚ùå No customer info available for premium status check');
        return { isPremium: false, isActive: false };
      }

      // T√ºm entitlement'larƒ± kontrol et - geni≈ü kapsam
      const allActiveEntitlements = this.currentCustomerInfo.entitlements.active;
      const entitlementKeys = Object.keys(allActiveEntitlements);
      
      debugLog('üîç Checking premium entitlements:', {
        totalActive: entitlementKeys.length,
        keys: entitlementKeys,
        targetEntitlement: REVENUECAT_CONFIG.entitlements.premium
      });

      // Birden fazla entitlement formatƒ±nƒ± kontrol et
      const premiumEntitlement = 
        allActiveEntitlements[REVENUECAT_CONFIG.entitlements.premium] ||  // Ana konfig√ºrasyon
        allActiveEntitlements['Premium Subscription'] ||  // Genel format
        allActiveEntitlements['premium'] ||  // K√º√ß√ºk harf
        allActiveEntitlements['Premium'] ||  // B√ºy√ºk ba≈üharf
        // Eƒüer hi√ßbiri yoksa, ilk aktif entitlement'ƒ± al (sandbox test i√ßin)
        (entitlementKeys.length > 0 ? allActiveEntitlements[entitlementKeys[0]] : null);

      if (!premiumEntitlement) {
        debugLog(
          '‚ùå No active premium entitlement found',
          {
            searchedKeys: [
              REVENUECAT_CONFIG.entitlements.premium,
              'Premium Subscription', 
              'premium', 
              'Premium'
            ],
            availableKeys: entitlementKeys,
            customerInfo: {
              userId: this.currentCustomerInfo.originalAppUserId,
              activeSubscriptions: Object.keys(this.currentCustomerInfo.activeSubscriptions)
            }
          }
        );
        return { isPremium: false, isActive: false };
      }

      const premiumStatus = {
        isPremium: true,
        isActive: premiumEntitlement.isActive,
        expirationDate: premiumEntitlement.expirationDate
          ? new Date(premiumEntitlement.expirationDate)
          : undefined,
        originalPurchaseDate: premiumEntitlement.originalPurchaseDate
          ? new Date(premiumEntitlement.originalPurchaseDate)
          : undefined,
        productId: premiumEntitlement.productIdentifier,
        willRenew: premiumEntitlement.willRenew,
      };
      
      debugLog('‚úÖ Premium status determined:', premiumStatus);
      return premiumStatus;
    } catch (error) {
      Logger.error('‚ùå Failed to get premium status:', error);
      return { isPremium: false, isActive: false };
    }
  }

  /**
   * Belirli bir premium √∂zelliƒüe eri≈üimi kontrol et
   */
  static async hasFeatureAccess(feature: PremiumFeature, forceRefresh = false): Promise<boolean> {
    const premiumStatus = await this.getPremiumStatus(forceRefresh);

    if (!premiumStatus.isPremium || !premiumStatus.isActive) {
      debugLog(`‚ùå Feature access denied for ${feature}: premium=${premiumStatus.isPremium}, active=${premiumStatus.isActive}`);
      return false;
    }

    const hasAccess = PREMIUM_FEATURES[feature] || false;
    debugLog(`üîë Feature access for ${feature}: ${hasAccess}`);
    return hasAccess;
  }

  /**
   * Mevcut offerings'leri getir (retry logic ile)
   */
  static async getOfferings(): Promise<PurchasesOffering[]> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    // Expo Go mock
    if (Constants.appOwnership === 'expo') {
      debugLog('üì± Expo Go: Returning mock offerings');
      return this.getMockOfferings();
    }

    let retryCount = 0;
    const maxRetries = 3;
    const retryDelay = 1000;

    while (retryCount < maxRetries) {
      try {
        debugLog(
          `üîÑ Fetching offerings (attempt ${retryCount + 1}/${maxRetries})...`
        );

        const offerings = await Purchases.getOfferings();

        if (!offerings) {
          throw new Error('Offerings object is null');
        }

        // T√ºm mevcut offering'leri d√∂nd√ºr
        const allOfferings = Object.values(offerings.all);
        
        if (allOfferings.length === 0) {
          if (retryCount < maxRetries - 1) {
            debugLog(`‚è≥ No offerings found, retrying in ${retryDelay}ms...`);
            await new Promise(resolve => setTimeout(resolve, retryDelay));
            retryCount++;
            continue;
          }

          throw new Error(
            'No offerings configured in RevenueCat dashboard. ' +
              'Please check your RevenueCat dashboard configuration.'
          );
        }

        // WeeklyOffering'i √∂ncelikle sƒ±rala
        const sortedOfferings = allOfferings.sort((a, b) => {
          if (a.identifier === 'WeeklyOffering') return -1;
          if (b.identifier === 'WeeklyOffering') return 1;
          if (a.identifier === 'Default') return -1;
          if (b.identifier === 'Default') return 1;
          return 0;
        });

        debugLog(`‚úÖ Found ${sortedOfferings.length} offering(s):`, 
          sortedOfferings.map(o => o.identifier));
        return sortedOfferings;
      } catch (error: any) {
        Logger.error(`‚ùå Attempt ${retryCount + 1} failed:`, error.message);

        if (retryCount < maxRetries - 1) {
          debugLog(`‚è≥ Retrying in ${retryDelay}ms...`);
          await new Promise(resolve => setTimeout(resolve, retryDelay));
          retryCount++;
        } else {
          // Development'ta mock data d√∂n
          if (__DEV__) {
            debugLog('üîß Development: Returning mock offerings');
            return this.getMockOfferings();
          }

          throw error;
        }
      }
    }

    throw new Error('Failed to fetch offerings after all retries');
  }

  /**
   * Mock offerings for development/Expo Go
   */
  private static getMockOfferings(): PurchasesOffering[] {
    return [
      // Weekly Offering
      {
        identifier: 'WeeklyOffering',
        serverDescription: 'Weekly Premium Subscription',
        availablePackages: [
          {
            identifier: '$rc_weekly',
            packageType: 'WEEKLY',
            product: {
              identifier: 'com.yemekbulucu.subscription.weekly',
              description: 'Premium Weekly Subscription',
              title: 'Premium Haftalƒ±k',
              price: 29.99,
              priceString: '‚Ç∫29,99',
              currencyCode: 'TRY',
              introPrice: null,
              discounts: null,
            },
            offeringIdentifier: 'WeeklyOffering',
          },
        ],
        lifetime: null,
        annual: null,
        sixMonth: null,
        threeMonth: null,
        twoMonth: null,
        monthly: null,
        weekly: {
          identifier: '$rc_weekly',
          packageType: 'WEEKLY',
          product: {
            identifier: 'com.yemekbulucu.subscription.weekly',
            description: 'Premium Weekly Subscription',
            title: 'Premium Haftalƒ±k',
            price: 29.99,
            priceString: '‚Ç∫29,99',
            currencyCode: 'TRY',
            introPrice: null,
            discounts: null,
          },
          offeringIdentifier: 'WeeklyOffering',
        } as any,
      } as any,
      // Monthly Offering (Default)
      {
        identifier: 'Default',
        serverDescription: 'Monthly Premium Subscription',
        availablePackages: [
          {
            identifier: '$rc_monthly',
            packageType: 'MONTHLY',
            product: {
              identifier: 'com.yemekbulucu.subscription.monthly',
              description: 'Premium Monthly Subscription',
              title: 'Premium Aylƒ±k',
              price: 79.99,
              priceString: '‚Ç∫79,99',
              currencyCode: 'TRY',
              introPrice: null,
              discounts: null,
            },
            offeringIdentifier: 'Default',
          },
        ],
        lifetime: null,
        annual: null,
        sixMonth: null,
        threeMonth: null,
        twoMonth: null,
        monthly: {
          identifier: '$rc_monthly',
          packageType: 'MONTHLY',
          product: {
            identifier: 'com.yemekbulucu.subscription.monthly',
            description: 'Premium Monthly Subscription',
            title: 'Premium Aylƒ±k',
            price: 79.99,
            priceString: '‚Ç∫79,99',
            currencyCode: 'TRY',
            introPrice: null,
            discounts: null,
          },
          offeringIdentifier: 'Default',
        } as any,
        weekly: null,
      } as any,
    ];
  }

  /**
   * Belirli paketi satƒ±n al
   */
  static async purchasePackage(
    purchasePackage: PurchasesPackage
  ): Promise<PurchaseResult> {
    try {
      if (!this.isInitialized) {
        await this.initialize();
      }

      // Expo Go kontrol√º
      if (Constants.appOwnership === 'expo') {
        debugLog('üì± Expo Go: Mock purchase');
        return {
          success: false,
          error: "Satƒ±n alma Expo Go'da √ßalƒ±≈ümaz. L√ºtfen build alƒ±n.",
        };
      }

      debugLog('üõí Starting purchase:', {
        identifier: purchasePackage.identifier,
        productId: purchasePackage.product.identifier,
      });

      const { customerInfo } = await Purchases.purchasePackage(purchasePackage);

      this.currentCustomerInfo = customerInfo;

      debugLog('‚úÖ Purchase successful');

      return {
        success: true,
        customerInfo,
      };
    } catch (error: any) {
      Logger.error('‚ùå Purchase failed:', error);

      // Kullanƒ±cƒ± iptal etti
      if (error.userCancelled) {
        debugLog('‚ÑπÔ∏è User cancelled purchase');
        return {
          success: false,
          userCancelled: true,
          error: 'Satƒ±n alma iptal edildi',
        };
      }

      // Error code'lara g√∂re mesaj
      let errorMessage = 'Satƒ±n alma i≈ülemi ba≈üarƒ±sƒ±z oldu';

      if (error.code === '1' || error.message?.includes('cancelled')) {
        return {
          success: false,
          userCancelled: true,
          error: 'Satƒ±n alma iptal edildi',
        };
      } else if (error.code === '2') {
        errorMessage = '√úr√ºn bulunamadƒ±';
      } else if (error.code === '3') {
        errorMessage = '√úr√ºn satƒ±n alƒ±namƒ±yor';
      } else if (error.code === '7') {
        errorMessage = 'Bu √ºr√ºn zaten satƒ±n alƒ±nmƒ±≈ü';
      } else if (error.code === '8') {
        errorMessage = 'Satƒ±n alma i≈ülemi hen√ºz tamamlanmadƒ±';
      }

      return {
        success: false,
        error: errorMessage,
      };
    }
  }

  /**
   * Satƒ±n almalarƒ± restore et
   */
  static async restorePurchases(): Promise<PurchaseResult> {
    try {
      if (!this.isInitialized) {
        await this.initialize();
      }

      // Expo Go kontrol√º
      if (Constants.appOwnership === 'expo') {
        debugLog('üì± Expo Go: Mock restore');
        return {
          success: false,
          error: "Restore Expo Go'da √ßalƒ±≈ümaz. L√ºtfen build alƒ±n.",
        };
      }

      debugLog('üîÑ Restoring purchases...');

      const customerInfo = await Purchases.restorePurchases();
      this.currentCustomerInfo = customerInfo;

      debugLog('‚úÖ Purchases restored:', {
        activeSubscriptions: Object.keys(customerInfo.activeSubscriptions),
      });

      return {
        success: true,
        customerInfo,
      };
    } catch (error: any) {
      Logger.error('‚ùå Restore failed:', error);
      return {
        success: false,
        error: error.message || 'Satƒ±n almalarƒ± geri y√ºkleme ba≈üarƒ±sƒ±z oldu',
      };
    }
  }

  /**
   * Kullanƒ±cƒ±yƒ± belirle (authentication'dan sonra)
   */
  static async identifyUser(userId: string): Promise<void> {
    try {
      if (!this.isInitialized) {
        await this.initialize();
      }

      await Purchases.logIn(userId);
      await this.refreshCustomerInfo();
      debugLog('üë§ User identified:', userId);
    } catch (error) {
      Logger.error('‚ùå Failed to identify user:', error);
      throw error;
    }
  }

  /**
   * Kullanƒ±cƒ± √ßƒ±kƒ±≈üƒ±
   */
  static async logoutUser(): Promise<void> {
    try {
      if (!this.isInitialized) {
        await this.initialize();
      }

      await Purchases.logOut();
      this.currentCustomerInfo = null;
      debugLog('üëã User logged out');
    } catch (error) {
      Logger.error('‚ùå Failed to logout user:', error);
      throw error;
    }
  }

  /**
   * Debug bilgileri
   */
  static getDebugInfo(): object {
    return {
      isInitialized: this.isInitialized,
      isExpoGo: Constants.appOwnership === 'expo',
      customerId: this.currentCustomerInfo?.originalAppUserId,
      activeSubscriptions: this.currentCustomerInfo
        ? Object.keys(this.currentCustomerInfo.activeSubscriptions)
        : [],
      activeEntitlements: this.currentCustomerInfo
        ? Object.keys(this.currentCustomerInfo.entitlements.active)
        : [],
    };
  }
}
