import { Recipe } from '../types/Recipe';

export interface RecipeGenerationRequest {
  ingredients: string[];
  mealTime?: 'breakfast' | 'lunch' | 'dinner' | 'snack';
  userProfile?: {
    dietaryRestrictions: string[];
    favoriteCategories: string[];
    cookingLevel: string;
    recipeHistory: number; // ka√ß tarif denemi≈ü
  };
  preferences?: {
    difficulty?: 'kolay' | 'orta' | 'zor';
    cookingTime?: number; // dakika
    servings?: number;
    dietary?: string[]; // ['vegan', 'glutensiz', 'laktozsuz']
    cuisine?: string; // 't√ºrk', 'italyan', '√ßin'
  };
  excludeIngredients?: string[];
}

export interface RecipeGenerationResponse {
  recipes: Recipe[];
  totalTokensUsed: number;
  estimatedCost: number; // USD
}

export class OpenAIService {
  private static readonly API_KEY = process.env.EXPO_PUBLIC_OPENAI_API_KEY;
  private static readonly BASE_URL = 'https://api.openai.com/v1/chat/completions';
  private static readonly MODEL = 'gpt-3.5-turbo';
  
  // Token fiyatlandƒ±rmasƒ± (GPT-3.5-turbo)
  private static readonly TOKEN_COST_PER_1K = 0.002; // $0.002 per 1K tokens

  /**
   * Malzemelere g√∂re AI ile tarif √ºret
   */
  static async generateRecipes(request: RecipeGenerationRequest): Promise<RecipeGenerationResponse> {
    try {
      if (!this.API_KEY || this.API_KEY === 'your_openai_api_key_here') {
        throw new Error('OpenAI API key bulunamadƒ±. L√ºtfen .env dosyasƒ±nƒ± kontrol edin.');
      }

      const prompt = this.buildPrompt(request);
      
      console.log('ü§ñ OpenAI API: Recipe generation started');
      console.log('üìù Ingredients:', request.ingredients);

      const response = await fetch(this.BASE_URL, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.API_KEY}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: this.MODEL,
          messages: [
            {
              role: 'system',
              content: 'Sen T√ºrk mutfaƒüƒ± konusunda uzman bir ≈üefsin. Verilen malzemelerle pratik, lezzetli tarifler √∂neriyorsun. Yanƒ±tlarƒ±nƒ± JSON formatƒ±nda ver.'
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          max_tokens: 2000,
          temperature: 0.8, // Yaratƒ±cƒ±lƒ±k i√ßin
          response_format: { type: "json_object" }
        })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`OpenAI API error: ${response.status} - ${errorData.error?.message || response.statusText}`);
      }

      const data = await response.json();
      const content = data.choices[0]?.message?.content;
      
      if (!content) {
        throw new Error('OpenAI\'dan yanƒ±t alƒ±namadƒ±');
      }

      // JSON parse et
      const parsedResponse = JSON.parse(content);
      const recipes = this.parseRecipesFromAI(parsedResponse);

      // Token kullanƒ±mƒ± ve maliyet hesapla
      const tokensUsed = data.usage?.total_tokens || 0;
      const estimatedCost = (tokensUsed / 1000) * this.TOKEN_COST_PER_1K;

      console.log('‚úÖ OpenAI API: Success');
      console.log(`üìä Tokens used: ${tokensUsed}, Cost: $${estimatedCost.toFixed(4)}`);
      console.log(`üçΩÔ∏è Generated ${recipes.length} recipes`);

      return {
        recipes,
        totalTokensUsed: tokensUsed,
        estimatedCost
      };

    } catch (error) {
      console.error('‚ùå OpenAI API Error:', error);
      throw error;
    }
  }

  /**
   * AI i√ßin adaptif prompt olu≈ütur
   */
  private static buildPrompt(request: RecipeGenerationRequest): string {
    const { ingredients, mealTime, userProfile, preferences, excludeIngredients } = request;
    
    // Adaptif strateji belirleme
    const recipeHistory = userProfile?.recipeHistory || 0;
    let strategy = 'conservative'; // 3 tercihli
    if (recipeHistory >= 5) strategy = 'balanced';    // 2+1
    if (recipeHistory >= 20) strategy = 'adventurous'; // 1+2
    
    // √ñƒü√ºn zamanƒ±na g√∂re √∂zel √∂neriler
    const mealTimePrompt = this.getMealTimePrompt(mealTime);
    
    let prompt = `${mealTimePrompt} Bu malzemeleri kullanarak 3 tarif √∂ner: ${ingredients.join(', ')}`;
    
    // Kullanƒ±cƒ± profili ekleme
    if (userProfile) {
      prompt += `\n\nKULLANICI PROFƒ∞Lƒ∞:`;
      if (userProfile.dietaryRestrictions.length) {
        prompt += `\n- Beslenme: ${userProfile.dietaryRestrictions.join(', ')}`;
      }
      if (userProfile.favoriteCategories.length) {
        prompt += `\n- Favori mutfaklar: ${userProfile.favoriteCategories.join(', ')}`;
      }
      if (userProfile.cookingLevel) {
        prompt += `\n- Mutfak deneyimi: ${userProfile.cookingLevel}`;
      }
    }
    
    // Adaptif strateji uygulama
    prompt += `\n\nTARƒ∞F DAƒûILIMI (${strategy.toUpperCase()}):`;
    
    if (strategy === 'conservative') {
      prompt += `\n- 3 tarif: Tamamen kullanƒ±cƒ± tercihlerine uygun`;
    } else if (strategy === 'balanced') {
      prompt += `\n- 2 tarif: Kullanƒ±cƒ± tercihlerine uygun üéØ`;
      prompt += `\n- 1 tarif: Yeni ke≈üif i√ßin farklƒ± mutfaktan üåü`;
    } else {
      prompt += `\n- 1 tarif: Kullanƒ±cƒ± tercihlerine uygun üéØ`;
      prompt += `\n- 2 tarif: Macera i√ßin yeni deneyimler üåü`;
    }
    
    // Diƒüer tercihler
    if (preferences?.difficulty) {
      prompt += `\nZorluk: ${preferences.difficulty}`;
    }
    if (preferences?.cookingTime) {
      prompt += `\nS√ºre: Max ${preferences.cookingTime} dakika`;
    }
    if (preferences?.servings) {
      prompt += `\nPorsiyon: ${preferences.servings} ki≈üi`;
    }
    if (excludeIngredients?.length) {
      prompt += `\nKullanma: ${excludeIngredients.join(', ')}`;
    }

    prompt += `\n\nYanƒ±tƒ±nƒ± ≈üu JSON formatƒ±nda ver:
{
  "recipes": [
    {
      "name": "Tarif Adƒ±",
      "description": "Kƒ±sa a√ßƒ±klama (max 100 karakter)",
      "ingredients": ["malzeme 1", "malzeme 2"],
      "instructions": ["adƒ±m 1", "adƒ±m 2", "adƒ±m 3"],
      "preparationTime": 15,
      "servings": 2,
      "difficulty": "kolay",
      "category": "ana_yemek",
      "recommendationType": "preference", // "preference" veya "discovery"
      "recommendationReason": "Neden √∂nerildiƒüini kƒ±saca a√ßƒ±kla",
      "tips": "ƒ∞pucu (opsiyonel)"
    }
  ]
}`;

    return prompt;
  }

  /**
   * AI yanƒ±tƒ±nƒ± Recipe formatƒ±na √ßevir
   */
  private static parseRecipesFromAI(aiResponse: any): Recipe[] {
    const recipes: Recipe[] = [];
    
    if (!aiResponse.recipes || !Array.isArray(aiResponse.recipes)) {
      throw new Error('AI yanƒ±tƒ± beklenmeyen formatta');
    }

    aiResponse.recipes.forEach((recipe: any, index: number) => {
      try {
        const parsedRecipe: Recipe = {
          id: `ai_${Date.now()}_${index}`,
          name: recipe.name || 'ƒ∞simsiz Tarif',
          description: recipe.description || 'AI tarafƒ±ndan √ºretilen tarif',
          ingredients: Array.isArray(recipe.ingredients) ? recipe.ingredients : [],
          instructions: Array.isArray(recipe.instructions) ? recipe.instructions : [],
          preparationTime: typeof recipe.preparationTime === 'number' ? recipe.preparationTime : undefined,
          servings: typeof recipe.servings === 'number' ? recipe.servings : undefined,
          difficulty: ['kolay', 'orta', 'zor'].includes(recipe.difficulty) ? recipe.difficulty : 'orta',
          category: recipe.category || 'ana_yemek',
          imageUrl: undefined, // AI hen√ºz g√∂rsel √ºretmiyor
          source: 'ai',
          aiGenerated: true,
          tips: recipe.tips
        };

        recipes.push(parsedRecipe);
      } catch (error) {
        console.warn(`‚ö†Ô∏è Recipe parsing error for index ${index}:`, error);
      }
    });

    return recipes;
  }

  /**
   * API durumunu kontrol et
   */
  static async checkApiStatus(): Promise<boolean> {
    try {
      if (!this.API_KEY || this.API_KEY === 'your_openai_api_key_here') {
        return false;
      }

      // Basit test isteƒüi
      const response = await fetch(this.BASE_URL, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.API_KEY}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: this.MODEL,
          messages: [{ role: 'user', content: 'Test' }],
          max_tokens: 5
        })
      });

      return response.ok;
    } catch (error) {
      console.error('‚ùå OpenAI API status check failed:', error);
      return false;
    }
  }

  /**
   * Tarif hakkƒ±nda soru-cevap
   */
  static async askRecipeQuestion(recipe: any, question: string): Promise<string> {
    try {
      if (!this.API_KEY || this.API_KEY === 'your_openai_api_key_here') {
        throw new Error('OpenAI API key bulunamadƒ±. L√ºtfen .env dosyasƒ±nƒ± kontrol edin.');
      }

      const prompt = this.buildQuestionPrompt(recipe, question);
      
      console.log('ü§ñ OpenAI API: Recipe Q&A started');
      console.log('‚ùì Question:', question);

      const response = await fetch(this.BASE_URL, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.API_KEY}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: this.MODEL,
          messages: [
            {
              role: 'system',
              content: 'Sen deneyimli bir ≈üef ve beslenme uzmanƒ±sƒ±n. Tariflerdeki sorularƒ± detaylƒ±, pratik ve yardƒ±mcƒ± ≈üekilde yanƒ±tlƒ±yorsun. Yanƒ±tlarƒ±n T√ºrk√ße olsun ve samimi bir dille konu≈ü.'
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          max_tokens: 500,
          temperature: 0.7
        })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`OpenAI API error: ${response.status} - ${errorData.error?.message || response.statusText}`);
      }

      const data = await response.json();
      const answer = data.choices[0]?.message?.content;
      
      if (!answer) {
        throw new Error('OpenAI\'dan yanƒ±t alƒ±namadƒ±');
      }

      console.log('‚úÖ OpenAI API: Q&A Success');
      return answer.trim();

    } catch (error) {
      console.error('‚ùå OpenAI Q&A Error:', error);
      throw error;
    }
  }

  /**
   * Soru i√ßin prompt olu≈ütur
   */
  private static buildQuestionPrompt(recipe: any, question: string): string {
    return `≈ûu tarif hakkƒ±nda soruyu yanƒ±tla:

TARƒ∞F:
Adƒ±: ${recipe.name}
A√ßƒ±klama: ${recipe.description || ''}
Malzemeler: ${recipe.ingredients?.join(', ') || ''}
Tarif: ${recipe.instructions?.join(' ') || ''}
S√ºre: ${recipe.preparationTime || recipe.cookingTime || 'Belirtilmemi≈ü'} dakika
Porsiyon: ${recipe.servings || 'Belirtilmemi≈ü'} ki≈üi
Zorluk: ${recipe.difficulty || 'Belirtilmemi≈ü'}

SORU: ${question}

L√ºtfen bu soruyu net, pratik ve yardƒ±mcƒ± ≈üekilde yanƒ±tla. Gerekirse alternatif √∂neriler de sun.`;
  }

  /**
   * √ñƒü√ºn zamanƒ±na g√∂re prompt
   */
  private static getMealTimePrompt(mealTime?: string): string {
    const mealTimePrompts = {
      breakfast: 'üåÖ KAHVALTI i√ßin',
      lunch: '‚òÄÔ∏è √ñƒûLE YEMEƒûƒ∞ i√ßin',
      dinner: 'üåÜ AK≈ûAM YEMEƒûƒ∞ i√ßin',
      snack: 'üçø ATI≈ûTIRMALIK i√ßin'
    };
    
    const timePrompt = mealTime ? mealTimePrompts[mealTime as keyof typeof mealTimePrompts] : '';
    return timePrompt || '';
  }

  /**
   * Token sayƒ±sƒ±nƒ± tahmin et (approximate)
   */
  static estimateTokens(text: string): number {
    // Rough estimation: 1 token ‚âà 4 characters for Turkish
    return Math.ceil(text.length / 4);
  }

  /**
   * Maliyet tahmini
   */
  static estimateCost(ingredients: string[], preferences?: any): number {
    const prompt = this.buildPrompt({ ingredients, preferences });
    const estimatedTokens = this.estimateTokens(prompt) + 1500; // Response tokens
    return (estimatedTokens / 1000) * this.TOKEN_COST_PER_1K;
  }
}